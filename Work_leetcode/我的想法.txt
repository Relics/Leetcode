几个general test case的问题：
1. 如果capacity是50，前50次操作均为set，第51次操作也为set，第52次操作为get。

--那么我并不知道用户替换了哪一个，那么除非用户输出了一个非之前set记录过的键值对，那么第52次操作我都只能算用户true，因为我不知道用户删了哪一个，甚至用户可能都没删。

2. 如果capacity是50，前100次操作均为set，第101次操作为get。

--那么这种情况更加复杂，因为test程序只能模拟结果，但是并无法按照capacity删除记录，我不知道用户删除了哪一个，我甚至不知道我的sample program删除了哪一个。那么我只能统统将set记录，无论用户返回什么（除非用户输出了一个非之前set记录过的键值对），我都只能算用户true。

3. 对于一个节点的frequency难以确定的问题：
--可能对于某一个一个key值，
	我的程序是---我先set，后没有删除了这个key值（counter保持不变，因为会出现frequency一样的情况），后继续操作
	sample case的程序是---先set，后删除了这个key值（counter清0），后继续set

------

我自己的想法是：
1. 如果用户和实际样例结果都为-1，那么判定用户为true

2. 如果用户和实际样例结果都不为-1，那么当且仅当用户和实际样例结果相同的结果时候判定用户为true

3. 如果用户为-1，实际样例不为-1，那么我直接把把key值从counter移除（因为用户自己都移除把这个键值对移除了）。
这种情况比较复杂，我尝试了进行其他判断，但是逻辑都有漏洞。
比如，我尝试判断用户这个已经删除的key值是否是least_common的，但是这个least_common是针对于用户在删除这个key值那个节点是否是least_common的，我并没有这方面的信息。
比如：
删除时（set操作时），key值为100这个节点的使用频率是100，其他的使用频率最小是101，但是往后我可能进行了N次set操作，第N+1次操作时（get key=100），用户返回-1，但是我没有办法比较，因为这个点的相对于现在使用频率特别高，相对于之前删除的那个时间点是使用频率最低的。
（核心点是我不知道用户是在哪一次操作把这个key值pop了）

4. 如果用户不为-1，实际样例为-1，那么我只能判断用户这个key值是否以前加过（可能后来被用户自己删除了），和这个用户输出的值是否能和key值的键值对对应上。

------

建议：
1. 我的水平有限，想法肯定是有漏洞的，实际上线该道题肯定会有漏判（因为test case的问题）和其他问题。

2. 把这道题题意修改为：
	每次删除《使用最不频繁的》，如果存在《多个使用最不频繁的》删除最早set的那一个，改为固定解的问题。